// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum Error {
    /// <p>The requested bucket name is not available. The bucket namespace is shared by all users of the system. Select a different name and try again.</p>
    BucketAlreadyExists(crate::types::error::BucketAlreadyExists),
    /// <p>The bucket you tried to create already exists, and you own it. Amazon S3 returns this error in all Amazon Web Services Regions except in the North Virginia Region. For legacy compatibility, if you re-create an existing bucket that you already own in the North Virginia Region, Amazon S3 returns 200 OK and resets the bucket access control lists (ACLs).</p>
    BucketAlreadyOwnedByYou(crate::types::error::BucketAlreadyOwnedByYou),
    /// <p>Object is archived and inaccessible until restored.</p>
    /// <p>If the object you are retrieving is stored in the S3 Glacier Flexible Retrieval storage class, the S3 Glacier Deep Archive storage class, the S3 Intelligent-Tiering Archive Access tier, or the S3 Intelligent-Tiering Deep Archive Access tier, before you can retrieve the object you must first restore a copy using <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_RestoreObject.html">RestoreObject</a>. Otherwise, this operation returns an <code>InvalidObjectState</code> error. For information about restoring archived objects, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/restoring-objects.html">Restoring Archived Objects</a> in the <i>Amazon S3 User Guide</i>.</p>
    InvalidObjectState(crate::types::error::InvalidObjectState),
    /// <p>The specified bucket does not exist.</p>
    NoSuchBucket(crate::types::error::NoSuchBucket),
    /// <p>The specified key does not exist.</p>
    NoSuchKey(crate::types::error::NoSuchKey),
    /// <p>The specified multipart upload does not exist.</p>
    NoSuchUpload(crate::types::error::NoSuchUpload),
    /// <p>The specified content does not exist.</p>
    NotFound(crate::types::error::NotFound),
    /// <p>This action is not allowed against this storage tier.</p>
    ObjectAlreadyInActiveTierError(crate::types::error::ObjectAlreadyInActiveTierError),
    /// <p>The source object of the COPY action is not in the active tier and is only stored in Amazon S3 Glacier.</p>
    ObjectNotInActiveTierError(crate::types::error::ObjectNotInActiveTierError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(
        note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-Error) for what information is available for the error."
    )]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::BucketAlreadyExists(inner) => inner.fmt(f),
            Error::BucketAlreadyOwnedByYou(inner) => inner.fmt(f),
            Error::InvalidObjectState(inner) => inner.fmt(f),
            Error::NoSuchBucket(inner) => inner.fmt(f),
            Error::NoSuchKey(inner) => inner.fmt(f),
            Error::NoSuchUpload(inner) => inner.fmt(f),
            Error::NotFound(inner) => inner.fmt(f),
            Error::ObjectAlreadyInActiveTierError(inner) => inner.fmt(f),
            Error::ObjectNotInActiveTierError(inner) => inner.fmt(f),
            Error::Unhandled(_) => {
                if let ::std::option::Option::Some(code) =
                    ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
                {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl From<::aws_smithy_types::error::operation::BuildError> for Error {
    fn from(value: ::aws_smithy_types::error::operation::BuildError) -> Self {
        Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: value.into(),
            meta: ::std::default::Default::default(),
        })
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for Error {
    fn meta(&self) -> &::aws_smithy_types::error::metadata::ErrorMetadata {
        match self {
            Self::BucketAlreadyExists(inner) => inner.meta(),
            Self::BucketAlreadyOwnedByYou(inner) => inner.meta(),
            Self::InvalidObjectState(inner) => inner.meta(),
            Self::NoSuchBucket(inner) => inner.meta(),
            Self::NoSuchKey(inner) => inner.meta(),
            Self::NoSuchUpload(inner) => inner.meta(),
            Self::NotFound(inner) => inner.meta(),
            Self::ObjectAlreadyInActiveTierError(inner) => inner.meta(),
            Self::ObjectNotInActiveTierError(inner) => inner.meta(),
            Self::Unhandled(inner) => &inner.meta,
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::complete_multipart_upload::CompleteMultipartUploadError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::complete_multipart_upload::CompleteMultipartUploadError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::complete_multipart_upload::CompleteMultipartUploadError> for Error {
    fn from(
        err: crate::operation::complete_multipart_upload::CompleteMultipartUploadError,
    ) -> Self {
        match err {
            crate::operation::complete_multipart_upload::CompleteMultipartUploadError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_bucket::CreateBucketError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_bucket::CreateBucketError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::create_bucket::CreateBucketError> for Error {
    fn from(err: crate::operation::create_bucket::CreateBucketError) -> Self {
        match err {
            crate::operation::create_bucket::CreateBucketError::BucketAlreadyExists(inner) => {
                Error::BucketAlreadyExists(inner)
            }
            crate::operation::create_bucket::CreateBucketError::BucketAlreadyOwnedByYou(inner) => {
                Error::BucketAlreadyOwnedByYou(inner)
            }
            crate::operation::create_bucket::CreateBucketError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_multipart_upload::CreateMultipartUploadError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_multipart_upload::CreateMultipartUploadError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::create_multipart_upload::CreateMultipartUploadError> for Error {
    fn from(err: crate::operation::create_multipart_upload::CreateMultipartUploadError) -> Self {
        match err {
            crate::operation::create_multipart_upload::CreateMultipartUploadError::Unhandled(
                inner,
            ) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_bucket::DeleteBucketError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_bucket::DeleteBucketError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_bucket::DeleteBucketError> for Error {
    fn from(err: crate::operation::delete_bucket::DeleteBucketError) -> Self {
        match err {
            crate::operation::delete_bucket::DeleteBucketError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_bucket_ownership_controls::DeleteBucketOwnershipControlsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_bucket_ownership_controls::DeleteBucketOwnershipControlsError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_bucket_ownership_controls::DeleteBucketOwnershipControlsError>
    for Error
{
    fn from(
        err: crate::operation::delete_bucket_ownership_controls::DeleteBucketOwnershipControlsError,
    ) -> Self {
        match err {
            crate::operation::delete_bucket_ownership_controls::DeleteBucketOwnershipControlsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_objects::DeleteObjectsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_objects::DeleteObjectsError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_objects::DeleteObjectsError> for Error {
    fn from(err: crate::operation::delete_objects::DeleteObjectsError) -> Self {
        match err {
            crate::operation::delete_objects::DeleteObjectsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_public_access_block::DeletePublicAccessBlockError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_public_access_block::DeletePublicAccessBlockError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_public_access_block::DeletePublicAccessBlockError> for Error {
    fn from(
        err: crate::operation::delete_public_access_block::DeletePublicAccessBlockError,
    ) -> Self {
        match err {
            crate::operation::delete_public_access_block::DeletePublicAccessBlockError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}

impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_object::GetObjectError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::get_object::GetObjectError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::get_object::GetObjectError> for Error {
    fn from(err: crate::operation::get_object::GetObjectError) -> Self {
        match err {
            crate::operation::get_object::GetObjectError::InvalidObjectState(inner) => {
                Error::InvalidObjectState(inner)
            }
            crate::operation::get_object::GetObjectError::NoSuchKey(inner) => {
                Error::NoSuchKey(inner)
            }
            crate::operation::get_object::GetObjectError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::head_object::HeadObjectError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::head_object::HeadObjectError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::head_object::HeadObjectError> for Error {
    fn from(err: crate::operation::head_object::HeadObjectError) -> Self {
        match err {
            crate::operation::head_object::HeadObjectError::NotFound(inner) => {
                Error::NotFound(inner)
            }
            crate::operation::head_object::HeadObjectError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_objects_v2::ListObjectsV2Error,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::list_objects_v2::ListObjectsV2Error,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::list_objects_v2::ListObjectsV2Error> for Error {
    fn from(err: crate::operation::list_objects_v2::ListObjectsV2Error) -> Self {
        match err {
            crate::operation::list_objects_v2::ListObjectsV2Error::NoSuchBucket(inner) => {
                Error::NoSuchBucket(inner)
            }
            crate::operation::list_objects_v2::ListObjectsV2Error::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_bucket_acl::PutBucketAclError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_bucket_acl::PutBucketAclError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::put_bucket_acl::PutBucketAclError> for Error {
    fn from(err: crate::operation::put_bucket_acl::PutBucketAclError) -> Self {
        match err {
            crate::operation::put_bucket_acl::PutBucketAclError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_object::PutObjectError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_object::PutObjectError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::put_object::PutObjectError> for Error {
    fn from(err: crate::operation::put_object::PutObjectError) -> Self {
        match err {
            crate::operation::put_object::PutObjectError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::upload_part::UploadPartError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::upload_part::UploadPartError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::upload_part::UploadPartError> for Error {
    fn from(err: crate::operation::upload_part::UploadPartError) -> Self {
        match err {
            crate::operation::upload_part::UploadPartError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_object::DeleteObjectError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::delete_object::DeleteObjectError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::delete_object::DeleteObjectError> for Error {
    fn from(err: crate::operation::delete_object::DeleteObjectError) -> Self {
        match err {
            crate::operation::delete_object::DeleteObjectError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::types::error::SelectObjectContentEventStreamError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::types::error::SelectObjectContentEventStreamError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::types::error::SelectObjectContentEventStreamError> for Error {
    fn from(err: crate::types::error::SelectObjectContentEventStreamError) -> Self {
        match err {
            crate::types::error::SelectObjectContentEventStreamError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl ::std::error::Error for Error {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Error::BucketAlreadyExists(inner) => inner.source(),
            Error::BucketAlreadyOwnedByYou(inner) => inner.source(),
            Error::InvalidObjectState(inner) => inner.source(),
            Error::NoSuchBucket(inner) => inner.source(),
            Error::NoSuchKey(inner) => inner.source(),
            Error::NoSuchUpload(inner) => inner.source(),
            Error::NotFound(inner) => inner.source(),
            Error::ObjectAlreadyInActiveTierError(inner) => inner.source(),
            Error::ObjectNotInActiveTierError(inner) => inner.source(),
            Error::Unhandled(inner) => ::std::option::Option::Some(&*inner.source),
        }
    }
}
impl crate::s3_request_id::RequestIdExt for Error {
    fn extended_request_id(&self) -> Option<&str> {
        match self {
            Self::BucketAlreadyExists(e) => e.extended_request_id(),
            Self::BucketAlreadyOwnedByYou(e) => e.extended_request_id(),
            Self::InvalidObjectState(e) => e.extended_request_id(),
            Self::NoSuchBucket(e) => e.extended_request_id(),
            Self::NoSuchKey(e) => e.extended_request_id(),
            Self::NoSuchUpload(e) => e.extended_request_id(),
            Self::NotFound(e) => e.extended_request_id(),
            Self::ObjectAlreadyInActiveTierError(e) => e.extended_request_id(),
            Self::ObjectNotInActiveTierError(e) => e.extended_request_id(),
            Self::Unhandled(e) => e.meta.extended_request_id(),
        }
    }
}
impl ::aws_types::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::BucketAlreadyExists(e) => e.request_id(),
            Self::BucketAlreadyOwnedByYou(e) => e.request_id(),
            Self::InvalidObjectState(e) => e.request_id(),
            Self::NoSuchBucket(e) => e.request_id(),
            Self::NoSuchKey(e) => e.request_id(),
            Self::NoSuchUpload(e) => e.request_id(),
            Self::NotFound(e) => e.request_id(),
            Self::ObjectAlreadyInActiveTierError(e) => e.request_id(),
            Self::ObjectNotInActiveTierError(e) => e.request_id(),
            Self::Unhandled(e) => e.meta.request_id(),
        }
    }
}
