// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum Error {
    /// <p>The specified code signing configuration does not exist.</p>
    CodeSigningConfigNotFoundException(crate::types::error::CodeSigningConfigNotFoundException),
    /// <p>Your Amazon Web Services account has exceeded its maximum total code size. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html">Lambda quotas</a>.</p>
    CodeStorageExceededException(crate::types::error::CodeStorageExceededException),
    /// <p>The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy is set to ENFORCE. Lambda blocks the deployment.</p>
    CodeVerificationFailedException(crate::types::error::CodeVerificationFailedException),
    /// <p>Need additional permissions to configure VPC settings.</p>
    Ec2AccessDeniedException(crate::types::error::Ec2AccessDeniedException),
    /// <p>Amazon EC2 throttled Lambda during Lambda function initialization using the execution role provided for the function.</p>
    Ec2ThrottledException(crate::types::error::Ec2ThrottledException),
    /// <p>Lambda received an unexpected Amazon EC2 client exception while setting up for the Lambda function.</p>
    Ec2UnexpectedException(crate::types::error::Ec2UnexpectedException),
    /// <p>An error occurred when reading from or writing to a connected file system.</p>
    EfsioException(crate::types::error::EfsioException),
    /// <p>The Lambda function couldn't make a network connection to the configured file system.</p>
    EfsMountConnectivityException(crate::types::error::EfsMountConnectivityException),
    /// <p>The Lambda function couldn't mount the configured file system due to a permission or configuration issue.</p>
    EfsMountFailureException(crate::types::error::EfsMountFailureException),
    /// <p>The Lambda function made a network connection to the configured file system, but the mount operation timed out.</p>
    EfsMountTimeoutException(crate::types::error::EfsMountTimeoutException),
    /// <p>Lambda couldn't create an elastic network interface in the VPC, specified as part of Lambda function configuration, because the limit for network interfaces has been reached. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html">Lambda quotas</a>.</p>
    EniLimitReachedException(crate::types::error::EniLimitReachedException),
    /// <p>The code signature failed the integrity check. If the integrity check fails, then Lambda blocks deployment, even if the code signing policy is set to WARN.</p>
    InvalidCodeSignatureException(crate::types::error::InvalidCodeSignatureException),
    /// <p>One of the parameters in the request is not valid.</p>
    InvalidParameterValueException(crate::types::error::InvalidParameterValueException),
    /// <p>The request body could not be parsed as JSON.</p>
    InvalidRequestContentException(crate::types::error::InvalidRequestContentException),
    /// <p>The runtime or runtime version specified is not supported.</p>
    InvalidRuntimeException(crate::types::error::InvalidRuntimeException),
    /// <p>The security group ID provided in the Lambda function VPC configuration is not valid.</p>
    InvalidSecurityGroupIdException(crate::types::error::InvalidSecurityGroupIdException),
    /// <p>The subnet ID provided in the Lambda function VPC configuration is not valid.</p>
    InvalidSubnetIdException(crate::types::error::InvalidSubnetIdException),
    /// <p>Lambda could not unzip the deployment package.</p>
    InvalidZipFileException(crate::types::error::InvalidZipFileException),
    /// <p>Lambda couldn't decrypt the environment variables because KMS access was denied. Check the Lambda function's KMS permissions.</p>
    KmsAccessDeniedException(crate::types::error::KmsAccessDeniedException),
    /// <p>Lambda couldn't decrypt the environment variables because the KMS key used is disabled. Check the Lambda function's KMS key settings.</p>
    KmsDisabledException(crate::types::error::KmsDisabledException),
    /// <p>Lambda couldn't decrypt the environment variables because the state of the KMS key used is not valid for Decrypt. Check the function's KMS key settings.</p>
    KmsInvalidStateException(crate::types::error::KmsInvalidStateException),
    /// <p>Lambda couldn't decrypt the environment variables because the KMS key was not found. Check the function's KMS key settings.</p>
    KmsNotFoundException(crate::types::error::KmsNotFoundException),
    /// <p>The permissions policy for the resource is too large. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html">Lambda quotas</a>.</p>
    PolicyLengthExceededException(crate::types::error::PolicyLengthExceededException),
    /// <p>The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the <code>GetFunction</code> or the <code>GetAlias</code> API operation to retrieve the latest RevisionId for your resource.</p>
    PreconditionFailedException(crate::types::error::PreconditionFailedException),
    /// <p>The specified configuration does not exist.</p>
    ProvisionedConcurrencyConfigNotFoundException(
        crate::types::error::ProvisionedConcurrencyConfigNotFoundException,
    ),
    /// <p>Lambda has detected your function being invoked in a recursive loop with other Amazon Web Services resources and stopped your function's invocation.</p>
    RecursiveInvocationException(crate::types::error::RecursiveInvocationException),
    /// <p>The request payload exceeded the <code>Invoke</code> request body JSON input quota. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html">Lambda quotas</a>.</p>
    RequestTooLargeException(crate::types::error::RequestTooLargeException),
    /// <p>The resource already exists, or another operation is in progress.</p>
    ResourceConflictException(crate::types::error::ResourceConflictException),
    /// <p>The operation conflicts with the resource's availability. For example, you tried to update an event source mapping in the CREATING state, or you tried to delete an event source mapping currently UPDATING.</p>
    ResourceInUseException(crate::types::error::ResourceInUseException),
    /// <p>The resource specified in the request does not exist.</p>
    ResourceNotFoundException(crate::types::error::ResourceNotFoundException),
    /// <p>The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to reestablish and try again.</p>
    ResourceNotReadyException(crate::types::error::ResourceNotReadyException),
    /// <p>The Lambda service encountered an internal error.</p>
    ServiceException(crate::types::error::ServiceException),
    /// <p>The <code>afterRestore()</code> <a href="https://docs.aws.amazon.com/lambda/latest/dg/snapstart-runtime-hooks.html">runtime hook</a> encountered an error. For more information, check the Amazon CloudWatch logs.</p>
    SnapStartException(crate::types::error::SnapStartException),
    /// <p>Lambda is initializing your function. You can invoke the function when the <a href="https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html">function state</a> becomes <code>Active</code>.</p>
    SnapStartNotReadyException(crate::types::error::SnapStartNotReadyException),
    /// <p>Lambda couldn't restore the snapshot within the timeout limit.</p>
    SnapStartTimeoutException(crate::types::error::SnapStartTimeoutException),
    /// <p>Lambda couldn't set up VPC access for the Lambda function because one or more configured subnets has no available IP addresses.</p>
    SubnetIpAddressLimitReachedException(crate::types::error::SubnetIpAddressLimitReachedException),
    /// <p>The request throughput limit was exceeded. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html#api-requests">Lambda quotas</a>.</p>
    TooManyRequestsException(crate::types::error::TooManyRequestsException),
    /// <p>The content type of the <code>Invoke</code> request body is not JSON.</p>
    UnsupportedMediaTypeException(crate::types::error::UnsupportedMediaTypeException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(
        note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-Error) for what information is available for the error."
    )]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::CodeSigningConfigNotFoundException(inner) => inner.fmt(f),
            Error::CodeStorageExceededException(inner) => inner.fmt(f),
            Error::CodeVerificationFailedException(inner) => inner.fmt(f),
            Error::Ec2AccessDeniedException(inner) => inner.fmt(f),
            Error::Ec2ThrottledException(inner) => inner.fmt(f),
            Error::Ec2UnexpectedException(inner) => inner.fmt(f),
            Error::EfsioException(inner) => inner.fmt(f),
            Error::EfsMountConnectivityException(inner) => inner.fmt(f),
            Error::EfsMountFailureException(inner) => inner.fmt(f),
            Error::EfsMountTimeoutException(inner) => inner.fmt(f),
            Error::EniLimitReachedException(inner) => inner.fmt(f),
            Error::InvalidCodeSignatureException(inner) => inner.fmt(f),
            Error::InvalidParameterValueException(inner) => inner.fmt(f),
            Error::InvalidRequestContentException(inner) => inner.fmt(f),
            Error::InvalidRuntimeException(inner) => inner.fmt(f),
            Error::InvalidSecurityGroupIdException(inner) => inner.fmt(f),
            Error::InvalidSubnetIdException(inner) => inner.fmt(f),
            Error::InvalidZipFileException(inner) => inner.fmt(f),
            Error::KmsAccessDeniedException(inner) => inner.fmt(f),
            Error::KmsDisabledException(inner) => inner.fmt(f),
            Error::KmsInvalidStateException(inner) => inner.fmt(f),
            Error::KmsNotFoundException(inner) => inner.fmt(f),
            Error::PolicyLengthExceededException(inner) => inner.fmt(f),
            Error::PreconditionFailedException(inner) => inner.fmt(f),
            Error::ProvisionedConcurrencyConfigNotFoundException(inner) => inner.fmt(f),
            Error::RecursiveInvocationException(inner) => inner.fmt(f),
            Error::RequestTooLargeException(inner) => inner.fmt(f),
            Error::ResourceConflictException(inner) => inner.fmt(f),
            Error::ResourceInUseException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::ResourceNotReadyException(inner) => inner.fmt(f),
            Error::ServiceException(inner) => inner.fmt(f),
            Error::SnapStartException(inner) => inner.fmt(f),
            Error::SnapStartNotReadyException(inner) => inner.fmt(f),
            Error::SnapStartTimeoutException(inner) => inner.fmt(f),
            Error::SubnetIpAddressLimitReachedException(inner) => inner.fmt(f),
            Error::TooManyRequestsException(inner) => inner.fmt(f),
            Error::UnsupportedMediaTypeException(inner) => inner.fmt(f),
            Error::Unhandled(_) => {
                if let ::std::option::Option::Some(code) =
                    ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
                {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl From<::aws_smithy_types::error::operation::BuildError> for Error {
    fn from(value: ::aws_smithy_types::error::operation::BuildError) -> Self {
        Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: value.into(),
            meta: ::std::default::Default::default(),
        })
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for Error {
    fn meta(&self) -> &::aws_smithy_types::error::metadata::ErrorMetadata {
        match self {
            Self::CodeSigningConfigNotFoundException(inner) => inner.meta(),
            Self::CodeStorageExceededException(inner) => inner.meta(),
            Self::CodeVerificationFailedException(inner) => inner.meta(),
            Self::Ec2AccessDeniedException(inner) => inner.meta(),
            Self::Ec2ThrottledException(inner) => inner.meta(),
            Self::Ec2UnexpectedException(inner) => inner.meta(),
            Self::EfsioException(inner) => inner.meta(),
            Self::EfsMountConnectivityException(inner) => inner.meta(),
            Self::EfsMountFailureException(inner) => inner.meta(),
            Self::EfsMountTimeoutException(inner) => inner.meta(),
            Self::EniLimitReachedException(inner) => inner.meta(),
            Self::InvalidCodeSignatureException(inner) => inner.meta(),
            Self::InvalidParameterValueException(inner) => inner.meta(),
            Self::InvalidRequestContentException(inner) => inner.meta(),
            Self::InvalidRuntimeException(inner) => inner.meta(),
            Self::InvalidSecurityGroupIdException(inner) => inner.meta(),
            Self::InvalidSubnetIdException(inner) => inner.meta(),
            Self::InvalidZipFileException(inner) => inner.meta(),
            Self::KmsAccessDeniedException(inner) => inner.meta(),
            Self::KmsDisabledException(inner) => inner.meta(),
            Self::KmsInvalidStateException(inner) => inner.meta(),
            Self::KmsNotFoundException(inner) => inner.meta(),
            Self::PolicyLengthExceededException(inner) => inner.meta(),
            Self::PreconditionFailedException(inner) => inner.meta(),
            Self::ProvisionedConcurrencyConfigNotFoundException(inner) => inner.meta(),
            Self::RecursiveInvocationException(inner) => inner.meta(),
            Self::RequestTooLargeException(inner) => inner.meta(),
            Self::ResourceConflictException(inner) => inner.meta(),
            Self::ResourceInUseException(inner) => inner.meta(),
            Self::ResourceNotFoundException(inner) => inner.meta(),
            Self::ResourceNotReadyException(inner) => inner.meta(),
            Self::ServiceException(inner) => inner.meta(),
            Self::SnapStartException(inner) => inner.meta(),
            Self::SnapStartNotReadyException(inner) => inner.meta(),
            Self::SnapStartTimeoutException(inner) => inner.meta(),
            Self::SubnetIpAddressLimitReachedException(inner) => inner.meta(),
            Self::TooManyRequestsException(inner) => inner.meta(),
            Self::UnsupportedMediaTypeException(inner) => inner.meta(),
            Self::Unhandled(inner) => &inner.meta,
        }
    }
}
impl<R>
    From<
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::invoke::InvokeError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::invoke::InvokeError,
            R,
        >,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::invoke::InvokeError> for Error {
    fn from(err: crate::operation::invoke::InvokeError) -> Self {
        match err {
            crate::operation::invoke::InvokeError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::operation::invoke::InvokeError::KmsNotFoundException(inner) => {
                Error::KmsNotFoundException(inner)
            }
            crate::operation::invoke::InvokeError::RecursiveInvocationException(inner) => {
                Error::RecursiveInvocationException(inner)
            }
            crate::operation::invoke::InvokeError::SnapStartException(inner) => {
                Error::SnapStartException(inner)
            }
            crate::operation::invoke::InvokeError::InvalidSubnetIdException(inner) => {
                Error::InvalidSubnetIdException(inner)
            }
            crate::operation::invoke::InvokeError::ServiceException(inner) => {
                Error::ServiceException(inner)
            }
            crate::operation::invoke::InvokeError::KmsDisabledException(inner) => {
                Error::KmsDisabledException(inner)
            }
            crate::operation::invoke::InvokeError::EfsioException(inner) => {
                Error::EfsioException(inner)
            }
            crate::operation::invoke::InvokeError::EfsMountConnectivityException(inner) => {
                Error::EfsMountConnectivityException(inner)
            }
            crate::operation::invoke::InvokeError::EfsMountFailureException(inner) => {
                Error::EfsMountFailureException(inner)
            }
            crate::operation::invoke::InvokeError::TooManyRequestsException(inner) => {
                Error::TooManyRequestsException(inner)
            }
            crate::operation::invoke::InvokeError::ResourceNotReadyException(inner) => {
                Error::ResourceNotReadyException(inner)
            }
            crate::operation::invoke::InvokeError::InvalidZipFileException(inner) => {
                Error::InvalidZipFileException(inner)
            }
            crate::operation::invoke::InvokeError::InvalidParameterValueException(inner) => {
                Error::InvalidParameterValueException(inner)
            }
            crate::operation::invoke::InvokeError::InvalidRequestContentException(inner) => {
                Error::InvalidRequestContentException(inner)
            }
            crate::operation::invoke::InvokeError::SnapStartTimeoutException(inner) => {
                Error::SnapStartTimeoutException(inner)
            }
            crate::operation::invoke::InvokeError::Ec2ThrottledException(inner) => {
                Error::Ec2ThrottledException(inner)
            }
            crate::operation::invoke::InvokeError::SubnetIpAddressLimitReachedException(inner) => {
                Error::SubnetIpAddressLimitReachedException(inner)
            }
            crate::operation::invoke::InvokeError::InvalidSecurityGroupIdException(inner) => {
                Error::InvalidSecurityGroupIdException(inner)
            }
            crate::operation::invoke::InvokeError::RequestTooLargeException(inner) => {
                Error::RequestTooLargeException(inner)
            }
            crate::operation::invoke::InvokeError::UnsupportedMediaTypeException(inner) => {
                Error::UnsupportedMediaTypeException(inner)
            }
            crate::operation::invoke::InvokeError::EfsMountTimeoutException(inner) => {
                Error::EfsMountTimeoutException(inner)
            }
            crate::operation::invoke::InvokeError::EniLimitReachedException(inner) => {
                Error::EniLimitReachedException(inner)
            }
            crate::operation::invoke::InvokeError::SnapStartNotReadyException(inner) => {
                Error::SnapStartNotReadyException(inner)
            }
            crate::operation::invoke::InvokeError::Ec2UnexpectedException(inner) => {
                Error::Ec2UnexpectedException(inner)
            }
            crate::operation::invoke::InvokeError::Ec2AccessDeniedException(inner) => {
                Error::Ec2AccessDeniedException(inner)
            }
            crate::operation::invoke::InvokeError::InvalidRuntimeException(inner) => {
                Error::InvalidRuntimeException(inner)
            }
            crate::operation::invoke::InvokeError::KmsAccessDeniedException(inner) => {
                Error::KmsAccessDeniedException(inner)
            }
            crate::operation::invoke::InvokeError::KmsInvalidStateException(inner) => {
                Error::KmsInvalidStateException(inner)
            }
            crate::operation::invoke::InvokeError::ResourceConflictException(inner) => {
                Error::ResourceConflictException(inner)
            }
            crate::operation::invoke::InvokeError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl ::std::error::Error for Error {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Error::CodeSigningConfigNotFoundException(inner) => inner.source(),
            Error::CodeStorageExceededException(inner) => inner.source(),
            Error::CodeVerificationFailedException(inner) => inner.source(),
            Error::Ec2AccessDeniedException(inner) => inner.source(),
            Error::Ec2ThrottledException(inner) => inner.source(),
            Error::Ec2UnexpectedException(inner) => inner.source(),
            Error::EfsioException(inner) => inner.source(),
            Error::EfsMountConnectivityException(inner) => inner.source(),
            Error::EfsMountFailureException(inner) => inner.source(),
            Error::EfsMountTimeoutException(inner) => inner.source(),
            Error::EniLimitReachedException(inner) => inner.source(),
            Error::InvalidCodeSignatureException(inner) => inner.source(),
            Error::InvalidParameterValueException(inner) => inner.source(),
            Error::InvalidRequestContentException(inner) => inner.source(),
            Error::InvalidRuntimeException(inner) => inner.source(),
            Error::InvalidSecurityGroupIdException(inner) => inner.source(),
            Error::InvalidSubnetIdException(inner) => inner.source(),
            Error::InvalidZipFileException(inner) => inner.source(),
            Error::KmsAccessDeniedException(inner) => inner.source(),
            Error::KmsDisabledException(inner) => inner.source(),
            Error::KmsInvalidStateException(inner) => inner.source(),
            Error::KmsNotFoundException(inner) => inner.source(),
            Error::PolicyLengthExceededException(inner) => inner.source(),
            Error::PreconditionFailedException(inner) => inner.source(),
            Error::ProvisionedConcurrencyConfigNotFoundException(inner) => inner.source(),
            Error::RecursiveInvocationException(inner) => inner.source(),
            Error::RequestTooLargeException(inner) => inner.source(),
            Error::ResourceConflictException(inner) => inner.source(),
            Error::ResourceInUseException(inner) => inner.source(),
            Error::ResourceNotFoundException(inner) => inner.source(),
            Error::ResourceNotReadyException(inner) => inner.source(),
            Error::ServiceException(inner) => inner.source(),
            Error::SnapStartException(inner) => inner.source(),
            Error::SnapStartNotReadyException(inner) => inner.source(),
            Error::SnapStartTimeoutException(inner) => inner.source(),
            Error::SubnetIpAddressLimitReachedException(inner) => inner.source(),
            Error::TooManyRequestsException(inner) => inner.source(),
            Error::UnsupportedMediaTypeException(inner) => inner.source(),
            Error::Unhandled(inner) => ::std::option::Option::Some(&*inner.source),
        }
    }
}
impl ::aws_types::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::CodeSigningConfigNotFoundException(e) => e.request_id(),
            Self::CodeStorageExceededException(e) => e.request_id(),
            Self::CodeVerificationFailedException(e) => e.request_id(),
            Self::Ec2AccessDeniedException(e) => e.request_id(),
            Self::Ec2ThrottledException(e) => e.request_id(),
            Self::Ec2UnexpectedException(e) => e.request_id(),
            Self::EfsioException(e) => e.request_id(),
            Self::EfsMountConnectivityException(e) => e.request_id(),
            Self::EfsMountFailureException(e) => e.request_id(),
            Self::EfsMountTimeoutException(e) => e.request_id(),
            Self::EniLimitReachedException(e) => e.request_id(),
            Self::InvalidCodeSignatureException(e) => e.request_id(),
            Self::InvalidParameterValueException(e) => e.request_id(),
            Self::InvalidRequestContentException(e) => e.request_id(),
            Self::InvalidRuntimeException(e) => e.request_id(),
            Self::InvalidSecurityGroupIdException(e) => e.request_id(),
            Self::InvalidSubnetIdException(e) => e.request_id(),
            Self::InvalidZipFileException(e) => e.request_id(),
            Self::KmsAccessDeniedException(e) => e.request_id(),
            Self::KmsDisabledException(e) => e.request_id(),
            Self::KmsInvalidStateException(e) => e.request_id(),
            Self::KmsNotFoundException(e) => e.request_id(),
            Self::PolicyLengthExceededException(e) => e.request_id(),
            Self::PreconditionFailedException(e) => e.request_id(),
            Self::ProvisionedConcurrencyConfigNotFoundException(e) => e.request_id(),
            Self::RecursiveInvocationException(e) => e.request_id(),
            Self::RequestTooLargeException(e) => e.request_id(),
            Self::ResourceConflictException(e) => e.request_id(),
            Self::ResourceInUseException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::ResourceNotReadyException(e) => e.request_id(),
            Self::ServiceException(e) => e.request_id(),
            Self::SnapStartException(e) => e.request_id(),
            Self::SnapStartNotReadyException(e) => e.request_id(),
            Self::SnapStartTimeoutException(e) => e.request_id(),
            Self::SubnetIpAddressLimitReachedException(e) => e.request_id(),
            Self::TooManyRequestsException(e) => e.request_id(),
            Self::UnsupportedMediaTypeException(e) => e.request_id(),
            Self::Unhandled(e) => e.meta.request_id(),
        }
    }
}
